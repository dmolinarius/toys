<!DOCTYPE html>
<html>
<meta charset="utf-8">
<!--
Shoot Bricks v0.0
-->
<title>MultiBall</title>
<style>

/* viewport properties */
html, body {
  padding: 0;
  margin: 0;
  font-family: Consolas;
}

#board, #playground {
  position: absolute;
  width: 56vmin;
  top: calc(50vh - 45vmin);
  left: calc(50vw - 31.5vmin - 2.5px);
  border-radius: 3px;
  border: 5px solid #400;
}

#board {
  background-color: #844;
  height: 90vmin;
  box-shadow: 1vw 1vh 1vmax #420;
  background: linear-gradient(#020, #003800);
}
#playground {
  border: 5px solid #400;
  background-color: transparent;
  height: 80vmin;
  box-shadow: inset -1px -1px 2px #800, inset 1px 1px 2px #400;
}
.block {
  position: absolute;
  line-height: 100%;
  text-align: center;
  font: menu;
  font-weight: bold;
}
.block.square {
  box-shadow: inset 0 0 3px black;
}
.block.triangle {
  overflow: hidden;
}
.block .triangle {
  width: 141%;
  height: 141%;
  box-shadow: inset 0 0 3px black, inset 0 0 3px black;
}
.block .overlay {
  position: absolute;
  width: calc(100% + 5px);
  height: calc(100% + 5px);
  box-shadow: inset 0 0 3px black, inset 0 0 3px black;
  line-height: 1.33em;
}
.block.topleft .triangle {
  transform: translate(-50%,-50%) rotateZ(45deg);
}
.block.topleft .overlay {
  top: 0;
  text-align: left;
  padding-left: 0.33em;
  padding-top: 0.33em;
}
.block.topright .triangle {
  transform: translate(-50%,-50%) rotateZ(45deg) translate(50%,-50%);
}
.block.topright .overlay {
  top: 0;
  right: 0;
  text-align: right;
  padding-right: 0.33em;
  padding-top: 0.33em;
}
.block.bottomright .triangle {
  transform: translate(-50%,-50%) rotateZ(45deg) translate(100%,0);
}
.block.bottomright .overlay {
  right: 0;
  bottom: 0;
}
.block.bottomright .overlay span {
  display: block;
  position: absolute;
  right: 0.33em;
  bottom: 0.33em;
}
.block.bottomleft .triangle {
  transform: translate(-50%,-50%) rotateZ(45deg) translate(50%,50%);
}
.block.bottomleft .overlay {
  bottom: 0;
}
.block.bottomleft .overlay span {
  display: block;
  position: absolute;
  left: 0.33em;
  bottom: 0.33em;
}
.bonus {
  position: absolute;
  box-sizing: border-box;
  border-style: solid;
}

#won, #lost {
  display: none;
  cursor: pointer;
  position: absolute;
  height: 4em;
  top: calc(50vh - 2em);
  text-align: center;
  font-size: 3vmin;
  letter-spacing: 0.1em;
  border-radius: 1vmin;
}
#lost {
  width:10em;
  line-height: 4em;
  left: calc(50vw - 5em);
  background-color: #f42;
  color: #ecc;
  box-shadow: inset 0 0 3px #300, 5px 5px 5px rgba(60,0,0,0.6);
  background: linear-gradient(#a00,#f42,#a00);
}
#won {
  width:15em;
  padding-top: 0.7em;
  box-sizing: border-box;
  line-height: 1.33em;
  left: calc(50vw - 7.5em);
  background-color: #192;
  color: #cec;
  box-shadow: inset 0 0 3px #300, 5px 5px 5px rgba(0,30,10,0.6);
  background: linear-gradient(#050,#192,#050);
}
#level_label {
  color: rgba(255,255,255,0.6);
  position: absolute;
  width: 100%;
  text-align: center;
  line-height: 9vmin;
  font-size: 3.5vmin;
}
#toolbox {
  position: absolute;
  bottom: 0;
  width: 100%;
  height: calc(10vmin - 3px);
  background: linear-gradient(#898, #ccc, #888);
  box-shadow: inset 0 0 5px black;
  border: none;
  font-size: 3.5vmin;
}
#home_button {
  cursor: default;
  position: absolute;
  width: 3em;
  height: 1.33em;
  line-height: 1.33em;
  left: calc(50% - 1.5em);
  top: calc(5vmin - 0.8em);
  text-align:center;
  border-radius: 3px;
  box-shadow: 0 0 2px black, inset 0 0 2px #777;
  border: 2px solid transparent;
}
#speed_box {
  height: 100%;
  position: absolute;
  width: calc(50% - 2.5em);
  right: 0;
}
input {
  width: 80%;
  display: block;
  position: absolute;
  top: 5vmin;
  height: 3vmin;
}
label {
  font-size: 3vmin;
  position: absolute;
  width: 100%;
  text-align: center;
  top: 0.33em;
}
output {
  display: inline;
  font-size: 3vmin;
}
#balls_label {
  font-size: 3vmin;
  text-align: left;
  padding: 0 0.5em;
  top: 0.5em;
  position: absolute;
}
#credits_label {
  font-size: 3vmin;
  text-align: left;
  padding: 0 0.5em;
  top: 1.5em;
  position: absolute;
}

</style>

<!-- where blocks live -->
<div id="board">
  <div id="level_label">level 1</div>
  <div id='toolbox'>
   <label id="balls_label">balls <output id="balls_value"></output></label>
   <label id="credits_label">credits <output id="credits_value"></output></label>
   <div id='home_button' title="Call running balls home">Home</div>
   <div id='speed_box' title="Adjust animation speed">
    <label for="speed_input">speed <output id="speed_value"></output></label>
    <input type="range" id='speed_input' name="speed_input" min="10" max="100" value="40">
   </div>
  </div>
</div>

<!-- where launcher & balls live -->
<canvas id="playground"></canvas>

<!-- Game Over popup -->
<div id="lost">Game Over !</div>

<!-- Congrats message -->
<div id="won">Congratulations<br>you completed level !</div>

<script>
var bw = parseInt(getComputedStyle(playground).getPropertyValue('border-top-width'),10)
  , ctx = playground.getContext('2d') // canvas context
  , state = 'waiting' // app state
  , launcher = null   // launcher object
  , next_pos          // next launcher position
  , blocksize = 0     // cell size
  , blocks = []       // list of block objects
  , nballs = 1        // number of balls to launch
  , launched_balls    // current number of launched balls
  , balls = []        // list of ball objects
  , radius = 0        // ball radius
  , borders = []      // list of borders where balls will bounce
  , level = 0         // current player level
  , speed             // animation speed
  , nloop             // recursion loop safeguard
  , credits = 0       // player credits
  , step = 0          // current animation step id
;

/* ****************************************************************************
**
** Moving ball
**
** ***************************************************************************/
class Ball {

  /*
  ** Balls are created with current radius, at launcher position,
  ** and direction depending on launcher orientation
  */
  constructor(id) {
    this.id = id;
    this.r = radius;
    this.x = launcher.x;
    this.y = launcher.y;
    this.dx = Math.sin(launcher.angle);
    this.dy = -Math.cos(launcher.angle);
    this.allow_bounces = 0;
    this.double = false;
    this.default_color = '#fff';
    this.color = this.default_color;
  }

  /*
  ** Manage bounces on bottom wall
  */
  bounce_more() {
    this.allow_bounces += 1;
    this.color = this.is_double() ? '#0ff' : '#f0f';
  }
  can_bounce() {
    return this.allow_bounces > 0;
  }
  bottom_bounce() {
    this.allow_bounces -= 1;
    this.unset_double();
    this.color = this.can_bounce() ? '#f0f' : this.default_color;
  }

  /*
  ** Manage doubled balls
  */
  is_double() {
    return this.double;
  }
  set_double() {
    this.double = true;
    this.default_color = '#0f0';
    this.color = this.default_color;
  }
  unset_double() {
    this.double = false;
    this.default_color = '#fff';
    this.color = this.default_color;
  }

  /*
  ** Move ball by given distance, eventually bouncing on obstacles
  */
  move(dist) {
    nloop = 0;
    let info = this.check_bounce({minm:2, dist, nx:0, ny:0, ball:this, o:null});
    this.x += this.dx * info.dist;
    this.y += this.dy * info.dist;
  }

  /*
  ** check if ball will bounce
  */
  check_bounce(info) {
    nloop += 1;
    info = borders.reduce((info,border) => border.check_bounce(info), info);
    if ( info.minm <=1 ) {
      if ( info.o ) info = info.o.hit(info);
      info = this.bounce(info);
      if ( nloop < 5 ) { // safeguard from too much recursion
        info = this.check_bounce({...info, minm:2, nx:0, ny:0, o:null});
      }
    }
    return info;
  }

  /*
  ** Compute new position after bouncing
  */
  bounce(info) {
    // new position at contact point
    this.x += info.minm * info.dist * this.dx
    this.y += info.minm * info.dist * this.dy;

    // new direction
    let sd = (this.dx * info.nx + this.dy * info.ny);
    this.dx = this.dx - 2 * sd * info.nx;
    this.dy = this.dy - 2 * sd * info.ny;

    // new dist
    return {...info, dist: (1-info.minm)*info.dist};
  }

  /*
  ** Draw ball on canvas
  */
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, 2*Math.PI);
    ctx.fill();
    ctx.restore();
  }

  /*
  ** Resize ball by given scale
  */
  resize(s) {
    this.x *= s;
    this.y *= s;
    this.r *= s;
  }
}


/* ****************************************************************************
**
** Ball Launcher
**
** ***************************************************************************/
class Launcher {

  /*
  ** Create Launcher
  */
  constructor() {
    this.position = 0.5;
    this.resize();
    this.angle = 0;
  }

  /*
  ** Update angle to shoot at given coordinates
  */
  lookat(x,y) {
    this.angle = Math.atan((x - this.x)/(this.y - y));
  }

  /*
  ** Move launcher
  */
  move(x) {
    this.x = x;
    this.angle = 0;
    this.position = x / playground.width;
  }

  /*
  ** Resize Launcher
  */
  resize() {
    this.x = this.position * playground.width;
    this.y = playground.height - 3*radius;
  }

  /*
  ** Draw Launcher on canvas
  */
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = 'lime';
    ctx.translate(this.x,this.y);
    ctx.rotate(this.angle);
    ctx.fillRect(-radius, -2*radius, 2*radius, 4*radius)
    ctx.restore();
  }
}

/* ****************************************************************************
**
** A Wall is a segment where balls will bounce
**
** ***************************************************************************/
class Wall {

  /*
  ** Create oriented segment
  ** Normal orientation will depend on order of given points
  */
  constructor(owner, x1,y1,x2,y2) {
    Object.assign(this,{owner, x1, y1, x2, y2});

    // vector
    this.ix = this.x2 - this.x1;
    this.iy = this.y2 - this.y1;

    // norm
    this.norm = Math.sqrt(this.ix*this.ix + this.iy*this.iy);

    // normal
    this.nx = (y1 - y2)/this.norm;
    this.ny = (x2 - x1)/this.norm;

    // wall is offset from segment by ball radius
    this.ax = this.x1 + this.nx * radius;
    this.ay = this.y1 + this.ny * radius;
  }

  /*
  ** Check if moving ball will bounce on segment
  ** https://openclassrooms.com/forum/sujet/calcul-du-point-d-intersection-de-deux-segments-21661
  ** to compute intersection of segments [AB] and [CD] where I is vector such as B = A + kI
  ** and J such as D = C + mJ, let's compute k and m and check if they are within interval [0,1]
  */
  check_bounce(info) {
    let cx = info.ball.x
      , cy = info.ball.y
      , jx = info.ball.dx*info.dist
      , jy = info.ball.dy*info.dist
    ;
    if ( this.nx*jx + this.ny*jy > 0 ) return info; // moving away
    let ax = this.ax, ay = this.ay, ix = this.ix, iy = this.iy
      , d = (ix*jy-iy*jx)
      , m = (ix*(ay-cy)+iy*(cx-ax))/d
    ;
    if ( m > 1 || m < 0 || m > info.minm) return info;
    let k = (jy*(cx-ax)+jx*(ay-cy))/d;
    if ( k > 1 || k < 0 ) return info;
    return {...info, minm:m, nx:this.nx, ny:this.ny, o:this.owner};
  }
}


/* ****************************************************************************
**
** Bottom wall
**
** ***************************************************************************/
class Bottom extends Wall {
  constructor(x1,y1,x2,y2) {
    super(null,x1,y1,x2,y2);
    this.owner = this;
  }
  hit(info) {
    let ball = info.ball;
    if ( next_pos === undefined ) next_pos = ball.x;
    if ( ball.can_bounce() ) {
      ball.bottom_bounce();
    }
    else {
      balls.splice(balls.indexOf(ball),1);
      if ( balls.length < 1 && launched_balls == nballs) {
        stop();
        next_turn();
      }
    }
    return info;
  }
}


/* ****************************************************************************
**
** Spheres are used to implement block corners and bonuses
**
** ***************************************************************************/
class Sphere {

  /*
  ** Create Sphere - Owner is block the corner belongs to
  */
  constructor(owner, x,y,r) {
    Object.assign(this,{owner, x, y, r});
    this.r2 = this.r * this.r;
  }

  /*
  ** Check if moving ball will bounce on sphere
  ** Model of ball is as above, model of sphere is P / OP = r
  */
  check_bounce(info) {
    let cx = info.ball.x
      , cy = info.ball.y
      , jx = info.ball.dx * info.dist
      , jy = info.ball.dy * info.dist
      , cmox = cx - this.x
      , cmoy = cy - this.y
    ;
    if ( cmox*jx + cmoy*jy > 0 ) return info; // moving away
    let a = jx*jx + jy*jy
      , b = 2*(cmox*jx + cmoy*jy)
      , c = cmox*cmox + cmoy*cmoy - this.r2
      , delta = b*b - 4*a*c
    ;
    if ( delta < 0 ) return info; // no intersection
    let sqd = Math.sqrt(delta)
      , m1 = (-b-sqd)/2/a
      , m2 = (-b+sqd)/2/a
    ;
    if ( (m1 < 0 || m1 > 1) && (m2 < 0 || m2 > 1) ) return info;
    let m;
    if ( m2 < 0 || m2 > 1) m = m1;
    else if ( m1 < 0 || m1 > 1 ) m = m2
    else m = Math.min(m1,m2);
    let n = this.normal(cx + m*jx, cy + m*jy);
    return m < info.minm ? {...info, minm:m, ...n, o:this.owner} : info;
  }

  /*
  ** returns normal at given point
  */
  normal(x,y) {
    return {
      nx: (x - this.x)/this.r,
      ny: (y - this.y)/this.r
    }
  }
}

/* ****************************************************************************
**
** Bonuses are special cells delivering a bonus when hit
**
** ***************************************************************************/
class Bonus extends Sphere {

  /*
  ** Create Bonus at given column and row
  */
  constructor(col,row) {
    let d = 0.1*blocksize;
    super(null,(col-0.5)*blocksize, (row-0.5)*blocksize, 4*d);
    Object.assign(this,{o:this, col, row});

    this.elt = document.createElement('div');
    this.elt.className = 'bonus';
    this.init && this.init();
    this.resize();
    window.board.appendChild(this.elt);
  }

  /*
  ** Resize bonus
  */
  resize() {
    this.r = 0.3 * blocksize,
    this.x = (this.col - 0.5)*blocksize;
    this.y = (this.row - 0.5)*blocksize;

    this.elt.style.left = (this.col-1)*blocksize+'px';
    this.elt.style.top = (this.row-1)*blocksize+'px';
    this.elt.style.width = this.r+'px';
    this.elt.style.height = this.r+'px';
    this.elt.style.borderWidth = (0.2*this.r)+'px';
    this.elt.style.marginLeft = 0.5*(blocksize-this.r)+'px';
    this.elt.style.marginTop = this.elt.style.marginLeft;
    this.elt.style.borderRadius = 0.5*this.r+'px';
  }

  /*
  ** Move one row down
  */
  next_row() {
    this.row += 1;
  }

  /*
  ** Register self as border
  */
  borders(a) {
    a.push(this);
    return a;
  }

  /*
  ** Check if bonus hit by given ball
  */
  check_bounce(info) {
    let check = super.check_bounce(info);
    if ( check.minm < info.minm ) info = this.hit(info,check);
    return info;
  }

  /*
  ** Bonus has been hit by given ball
  */
  hit(info) {
    console.log('bonus hit by ball',this,info);
    return info;
  }

  /*
  ** Delete bonus
  */
  delete() {
    blocks.splice(blocks.indexOf(this),1);
    borders.splice(borders.indexOf(this),1);
    this.elt.parentNode.removeChild(this.elt);
  }
}

/* ****************************************************************************
**
** Bonus to load one more ball into launcher
**
** ***************************************************************************/
class LauncherLoader extends Bonus {
  init() {
    this.elt.style.borderColor = 'rgba(255,90,0,0.9)';
    this.elt.style.backgroundColor = 'rgba(255,90,0,0.5)';
  }
  hit(info) {
    set_nballs(nballs+1);
    this.delete();
    return info;
  }
}

/* ****************************************************************************
**
** Bonus to let balls bounce on bottom
**
** ***************************************************************************/
class Bouncer extends Bonus {
  init() {
    this.elt.style.borderColor = 'rgba(255,0,255,0.9)';
    this.elt.style.backgroundColor = 'rgba(255,0,255,0.5)';
    this.hit_count = 0;
  }
  hit(info) {
    if ( !info.ball.can_bounce() ) info.ball.bounce_more();
    this.hit_count++;
    return info;
  }
  next_row() {
    if ( this.hit_count > 0 ) this.delete();
    else this.row += 1;
  }
}

/* ****************************************************************************
**
** Bonus to double balls
**
** ***************************************************************************/
class Doubler extends Bonus {
  init() {
    this.elt.style.borderColor = 'rgba(0,255,0,0.9)';
    this.elt.style.backgroundColor = 'rgba(0,255,0,0.5)';
    this.hit_count = 0;
    this.doubled = {};
  }
  hit(info,check) {
    let angle = 20 // deg
      , alpha = angle/180*Math.PI // radians
      , theta = (Math.PI-alpha)/2 // bouncing normal
      , ball = info.ball
      , dx = ball.dx
      , dy = ball.dy
    ;
    if ( !ball.is_double() && this.doubled[ball.id] != step) {
      // remember we already doubled this ball during the current animation step
      this.doubled[ball.id] = step;

      // prepare to move to the contact point and to bounce
      info.minm = check.minm;
      info.nx = dx * Math.cos(-theta) - dy * Math.sin(-theta);
      info.ny = dx * Math.sin(-theta) + dy * Math.cos(-theta);
      this.hit_count++;

      // create a new ball at bouncing point
      let ball2 = new Ball(nballs+ball.id);
      ball2.x = ball.x + info.minm * info.dist * dx;
      ball2.y = ball.y + info.minm * info.dist * dy;
      ball2.dx = dx * Math.cos(-alpha) - dy * Math.sin(-alpha);
      ball2.dy = dx * Math.sin(-alpha) + dy * Math.cos(-alpha);
      ball2.set_double();
      ball2.move(info.dist*(1-info.minm)); // may bounce
      balls.push(ball2);
    }
    return info;
  }
  next_row() {
    if ( this.hit_count > 0 ) this.delete();
    else this.row += 1;
  }
}


/* ****************************************************************************
**
** Blocks are the obstacles balls bounce on
**
** ***************************************************************************/
class Block {

  /*
  ** Blocks are created at given column and row, with current level
  */
  constructor(col,row,level) {
    Object.assign(this,{col, row, level});
    this.elt = document.createElement('div');
    this.elt.className = 'block';
    this.init && this.init();
    this.repaint();
    this.resize();
    window.board.appendChild(this.elt);
  }

  /*
  ** Translate block by one row
  */
  next_row() {
    this.row += 1;
  }

  /*
  ** Create borders where balls will bounce
  */
  borders(a) {
    this.coords().forEach( (c,i,cs) => {
      let p = i ? cs[i-1] : cs[cs.length-1];
      a.push(new Wall(this, c.x, c.y, p.x, p.y)); // wall
      a.push(new Sphere(this, c.x, c.y, radius)); // corner
    });
    return a;
  }

  /*
  ** Resize block
  */
  resize() {
    this.elt.style.left = (this.col-1)*blocksize+'px';
    this.elt.style.top = (this.row-1)*blocksize+'px';
    this.elt.style.width = blocksize+'px';
    this.elt.style.height = blocksize+'px';
    this.elt.style.lineHeight = blocksize+'px';
    this.elt.style.fontSize = (blocksize/4)+'px';
  }

  /*
  ** Repaint block with color depending on level
  */
  repaint() {
    let color = this.get_color()
    this.elt.style.backgroundColor = color;
    this.elt.style.color = invert_color(color);
  }

  /*
  ** return color from palette depending on level
  */
  get_color() {
    return get_color(this.level);
  }

  /*
  ** Block has been hit, decrease level and repaint
  ** or eventually delete block if level is < 1
  */
  hit(info) {
    this.level = this.level - 1;
    this.show_level();
    if ( this.level < 1 ) this.delete();
    else this.repaint();
    return info;
  }

  /*
  ** Remove block from list of blocks, walls, corners
  ** & delete DOM element
  */
  delete() {
    borders.filter(w => w.owner == this).forEach(w => {
      borders.splice(borders.indexOf(w),1);
    });
    blocks.splice(blocks.indexOf(this),1);
    if ( this.elt.parentNode ) {
      this.elt.parentNode.removeChild(this.elt);
    }
    else {
      console.log('Unparented Block elt ',this);
    }
  }
}

// Square block
class Square extends Block {
  init() {
    this.elt.classList.add('square');
    this.show_level();
  }
  coords() {
    return [
      { x: (this.col-1)*blocksize, y: (this.row-1)*blocksize },
      { x: (this.col  )*blocksize, y: (this.row-1)*blocksize },
      { x: (this.col  )*blocksize, y: (this.row  )*blocksize },
      { x: (this.col-1)*blocksize, y: (this.row  )*blocksize }
    ];
  }
  show_level() {
    this.elt.textContent = this.level;
  }
}

// Triangle block
class Triangle extends Block {
  init() {
    this.elt.classList.add('triangle');
    this.triangle = document.createElement('div');
    this.triangle.className = 'triangle';
    this.elt.appendChild(this.triangle);
    this.overlay = document.createElement('div');
    this.overlay.className = 'overlay';
    this.elt.appendChild(this.overlay);
  }
  repaint() {
    let color = this.get_color();
    this.triangle.style.backgroundColor = color;
    this.overlay.style.color = invert_color(color);
  }
}

// Top left triangular block
class TopLeftTriangle extends Triangle {
  init() {
    super.init();
    this.elt.classList.add('topleft');
    this.show_level();
  }
  coords() {
    return [
      { x: (this.col-1)*blocksize, y: (this.row-1)*blocksize },
      { x: (this.col  )*blocksize, y: (this.row-1)*blocksize },
      { x: (this.col-1)*blocksize, y: (this.row  )*blocksize }
    ];
  }
  show_level() {
    this.overlay.textContent = this.level;
  }
}

// Top right triangular block
class TopRightTriangle extends Triangle {
  init() {
    super.init();
    this.elt.classList.add('topright');
    this.show_level();
  }
  coords() {
    return [
      { x: (this.col-1)*blocksize, y: (this.row-1)*blocksize },
      { x: (this.col  )*blocksize, y: (this.row-1)*blocksize },
      { x: (this.col  )*blocksize, y: (this.row  )*blocksize }
    ];
  }
  show_level() {
    this.overlay.textContent = this.level;
  }
}

// Bottom right triangular block
class BottomRightTriangle extends Triangle {
  init() {
    super.init();
    this.elt.classList.add('bottomright');
    this.show_level();
  }
  coords() {
    return [
      { x: (this.col  )*blocksize, y: (this.row-1)*blocksize },
      { x: (this.col  )*blocksize, y: (this.row  )*blocksize },
      { x: (this.col-1)*blocksize, y: (this.row  )*blocksize }
    ];
  }
  show_level() {
    this.overlay.innerHTML = '<span>'+this.level+'</span>';
  }
}

// Bottom left triangular block
class BottomLeftTriangle extends Triangle {
  init() {
    super.init();
    this.elt.classList.add('bottomleft');
    this.show_level();
  }
  coords() {
    return [
      { x: (this.col-1)*blocksize, y: (this.row-1)*blocksize },
      { x: (this.col  )*blocksize, y: (this.row  )*blocksize },
      { x: (this.col-1)*blocksize, y: (this.row  )*blocksize }
    ];
  }
  show_level() {
    this.overlay.innerHTML = '<span>'+this.level+'</span>';
  }
}


/*
** block color palette
*/
// https://gka.github.io/palettes/#colors=#bfbfbf,#b08030,#9f2000,#3f2040,#000060,#000030|steps=255|bez=0|coL=1
var color_palette = [
'#bfbfbf','#bfbebd','#bfbdbc','#bfbdba','#bfbbb7','#bfbab5','#bfb9b3','#bfb9b1',
'#bfb8ae','#bfb7ac','#bfb6aa','#bfb5a8','#bfb4a6','#bfb3a3','#bfb1a1','#bfb09f',
'#bfaf9d','#bfaf9b','#bfae99','#bfad97','#bfac96','#bfab94','#bfaa92','#bfa990',
'#bea98d','#bea88b','#bea789','#bea687','#bea485','#bea482','#bda380','#bda27e',
'#bda17c','#bda07a','#bd9f78','#bc9f77','#bc9e75','#bc9d73','#bc9c71','#bb9a6e',
'#bb9a6c','#bb986a','#ba9868','#ba9665','#ba9663','#ba9562','#b99461','#b9945f',
'#b9925c','#b8915a','#b89158','#b79056','#b78f53','#b78d51','#b68d50','#b68c4e',
'#b68b4b','#b58a4a','#b58a48','#b48845','#b48843','#b38740','#b3853e','#b3853c',
'#b2843b','#b28339','#b18337','#b18234','#b08131','#b08030','#b07e2f','#b07e2e',
'#b07d2e','#b07b2d','#af7a2d','#af7a2c','#af772b','#af772a','#af752a','#af7429',
'#af7328','#ae7228','#ae7127','#ae7027','#ae6f26','#ae6e25','#ae6d24','#ad6c24',
'#ad6a23','#ad6922','#ad6922','#ad6721','#ad6621','#ac6520','#ac641f','#ac621e',
'#ac611e','#ac601d','#ab601d','#ab5e1c','#ab5d1b','#ab5b1a','#aa5a1a','#aa5a19',
'#aa5919','#aa5718','#a95517','#a95516','#a95416','#a95215','#a95114','#a85014',
'#a84e13','#a84e13','#a84b11','#a74b11','#a74910','#a7480f','#a7470f','#a6460e',
'#a6440e','#a6420d','#a5420c','#a5400c','#a53e0a','#a53e0a','#a43c09','#a43a08',
'#a43a08','#a43807','#a33607','#a33506','#a33305','#a23305','#a23004','#a22e04',
'#a12d03','#a12b03','#a12a02','#a02902','#a02701','#a02401','#9f2301','#9f2000',
'#9e2002','#9c2003','#9a2005','#992108','#972109','#95210b','#94210c','#92210e',
'#92210f','#8f2111','#8e2112','#8d2114','#8b2115','#8a2116','#872218','#872219',
'#84221a','#83221b','#81221c','#7f221e','#7f221e','#7d2220','#7c2220','#792222',
'#792222','#772224','#752225','#742225','#722227','#702228','#6e2228','#6c2229',
'#6c222a','#69222b','#68222c','#66222d','#64222e','#63222f','#612130','#612130',
'#5f2131','#5c2132','#5b2133','#592134','#572135','#552136','#532137','#522138',
'#4f2139','#4d213a','#4b213b','#4a213b','#49203b','#47203d','#45203d','#43203e',
'#41203f','#3f2040','#3e1f42','#3d1e42','#3d1d43','#3c1c44','#3a1b45','#391a46',
'#391947','#381848','#371749','#36164a','#35154a','#34144c','#33134c','#31134d',
'#30114e','#2f104f','#2e0f50','#2c0e51','#2b0d52','#2a0c53','#270b54','#250a55',
'#240956','#220857','#1f0758','#1d0659','#1b055a','#1a045a','#17045b','#13035c',
'#0d025e','#0b015e','#04005f','#00005f','#00015d','#00025a','#000258','#000355',
'#000352','#00034f','#00034e','#00034c','#000349','#000346','#000343','#000341',
'#01033e','#01023c','#010239','#020137','#010135','#010033','#000030','#00002d',
'#00002a','#000027','#000024','#000021','#00001e','#00001b','#000018','#000015',
'#000012','#000009','#000006','#000003'
];

/*
** Helper functions
*/
function rgb(h) {
  return h.substring(1).match(/.{2}/g).reduce((c,h) => [...c,parseInt(h,16)],[]);
}
function css_rgb(h) {
  return 'rgb('+rgb(h).join(',')+')';
}
function get_color(n) {
  return n > color_palette.length-1 ? '#000000' : color_palette[n];
}
function invert_color(hhh) {
  let c = hsl(rgb(hhh))
    , h = c[0]+180
    , css = css_hsl([h > 360 ? h-360 : h, (1-c[1]), (1-c[2])])
  ;
  return css;
}
function hsl(c) {
  let r = c[0]/255
    , g = c[1]/255
    , b = c[2]/255
    , cmax = Math.max(r,g,b)
    , cmin = Math.min(r,g,b)
    , delta = cmax - cmin
    , l = (cmax+cmin)/2
    , s = delta ? delta / (1-Math.abs(2*l-1)) : 0
    , h
  ;
  if ( delta == 0 ) h = 0;
  else if ( cmax == r ) h = 60*(((g-b)/delta)%6);
  else if ( cmax == g ) h = 60*(((b-r)/delta)+2);
  else if ( cmax == b ) h = 60*(((b-r)/delta)+4);
  return [h, s, l];
}
function css_hsl(c) {
  return 'hsl('+c[0]+'deg,'+c[1]*100+'%,'+c[2]*100+'%)';
}

/*
** Initialize app
*/
function initialize() {
  init_consts();
  set_nballs(1);
  set_level(1);
  set_credits(0);
  launcher = new Launcher(playground);
  update_blocks();
  resize();
}

/*
** Initialize app constants depending on window size
*/
function init_consts() {
  blocksize = playground.width / 7;
  radius = playground.width / 50;
}

/*
** Scroll existing blocks down, and create a new row of blocks
*/
function update_blocks() {
  var block_types = [TopLeftTriangle, TopRightTriangle, BottomRightTriangle, BottomLeftTriangle, Square]
    , bonus_types = [Bouncer, Doubler]
    , available_cols = [1, 2, 3, 4, 5, 6, 7]
  ;
  //test_palette(); return;

  // move existing cells one row down
  // warning : next_row() may splice blocks...
  blocks.slice().forEach(b => b.next_row());

  // generate from 2 to 5 random blocks
  let num = 2 + random_int(3)
  for ( let n=0; n < num; n++ ) {
    let i = random_int(available_cols.length)
      , block = block_types[Math.min(random_int(10)-1,block_types.length-1)]
    ;
    blocks.push(new block(available_cols[i-1],2,Math.floor(6*level/num)));
    available_cols.splice(i-1,1);
  }

  // generate LauncherLoader at random available position
  let i = random_int(available_cols.length);
  blocks.push(new LauncherLoader(available_cols[i-1],2));
  available_cols.splice(i-1,1);

  // eventually generate a bonus
  if ( available_cols.length > 1 && random_int(3) > 1 ) {
    let i = random_int(available_cols.length)
      , bonus = bonus_types[random_int(bonus_types.length)-1]
    ;
    blocks.push(new bonus(available_cols[i-1],2));
    available_cols.splice(i-1,1);
  }
}

/*
** not used in normal use - display block color palette
*/
function test_palette() {
  for ( let row = 0; row < 10 ; row++ ) {
    for ( let col = 0; col < 7; col++ ) {
      blocks.push(new Square(col+1,row+1, 1 + row*7 + col));
    }
  }
}

/*
** Helper function, return a random integer
*/
function random_int(max) {
  var n = Math.ceil(Math.random() * max);
  return n;
}

/*
** Create walls and corners from playground borders and blocks
*/
function init_borders() {
  // playground borders
  borders = [
    new Wall(null,0,0, playground.width,0),
    new Wall(null,playground.width,0, playground.width,playground.height),
    new Bottom(playground.width,playground.height, 0,playground.height),
    new Wall(null,0,playground.height, 0,0)
  ];
  // blocks
  borders = blocks.reduce((a,b) => b.borders(a),borders);
}

/*
** Resize whole app
*/
function resize() {
  let scale = playground.clientWidth/playground.width;
  playground.width = playground.clientWidth;
  playground.height = playground.clientHeight;
  init_consts();
  launcher.resize(playground);
  blocks.forEach(b => b.resize());
  balls.forEach(b => b.resize(scale));
  init_borders();
  change_speed();
  redraw();
}

/*
** Redraw canvas
*/
function redraw() {
  erase();
  launcher.draw(ctx);
  balls.forEach(b => b.draw(ctx));
}

/*
* Erase canvas
*/
function erase() {
  ctx.clearRect(0,0,playground.width,playground.height);
}

/*
** mouse down on canvas - start shooting
*/
function start_shooting(e) {
  playground.removeEventListener('mousedown',start_shooting);
  playground.addEventListener('mousemove',shoot);
  playground.addEventListener('mouseup',fire);
}

/*
** mouse move on canvas - shoot
*/
function shoot(e) {
  var x = e.layerX - bw
    , y = Math.min(launcher.y - radius, e.layerY - bw)
  ;
  state = 'shooting';

  erase();
  launcher.lookat(x,y);
  launcher.draw(ctx);

  ctx.save();
  ctx.strokeStyle = 'white';
  ctx.setLineDash([2,2]);
  ctx.beginPath();
  ctx.moveTo(launcher.x,launcher.y);
  ctx.lineTo(x,y);
  ctx.stroke();
  ctx.restore();
}

/*
** mouse up on canvas - fire balls
*/
function fire(e) {
  playground.removeEventListener('mousemove',shoot);
  playground.removeEventListener('mouseup',fire);

  let start = null          // animation start timestamp
    , previous = null       // previous animation step timestamp
  ;
  step = 0;
  state = 'playing';
  balls = [];
  launched_balls = 0;
  home_button.addEventListener('click',home);
  home_button.style.cursor = 'pointer';
  requestAnimationFrame(nextStep);

  /*
  ** functions below inlined to use closure
  */

  // launch a new ball
  function launch_ball() {
    balls.push(new Ball(launched_balls+1));
    launched_balls += 1;
  }

  // animation step
  function nextStep(timestamp) {
    if ( !start ) {
      start = timestamp;
      previous = start;
    }
    step += 1;

    // while some balls still to launch ...
    if ( state=='playing' && launched_balls < nballs ) {
      // launch first ball ...
      if (balls.length == 0) launch_ball();
      // ... and other ones at 3 radius distance from each other
      else {
        let ball = balls[balls.length-1]
          , dx = ball.x - launcher.x
          , dy = ball.y - launcher.y
          , d = Math.sqrt(dx*dx + dy*dy)
        ;
        if ( d > radius*3 ) launch_ball();
      }
    }

    // move all balls forward and redraw
    let dist = (timestamp - previous) * speed;
    balls.forEach(b => b.move(dist));
    redraw();

    if ( blocks.filter(b => !(b instanceof Bonus)).length < 1 ) game_over(won);

    // if still playing register next animation step
    if ( state == 'playing' ) requestAnimationFrame(nextStep);
    previous = timestamp;
  }
}

/*
** end current turn by recalling all moving balls home
*/
function home(e) {
  home_button.removeEventListener('click',home);
  home_button.style.cursor = 'default';
  stop();
  balls = [];
  next_turn();
}

/*
** be prepared to shoot again
*/
function stop() {
  state = 'waiting';
  playground.addEventListener('mousedown',start_shooting);
}

/*
** prepare next turn
*/
function next_turn() {
  let bks =  blocks.filter(b => b.row > 8);
  if ( bks.length > 0 ) {
    let bns = bks.filter(b => b instanceof Bonus);
    if (bns.length < bks.length) game_over(lost);
    else bns.forEach(function(b) {
      if (b instanceof LauncherLoader) b.hit(); // calls b.delete()
      else b.delete()
    });
  }
  else next_level();
}

/*
** start next level
*/
function next_level() {
  set_level(level+1);
  if ( next_pos !== undefined ) launcher.move(next_pos);
  next_pos = undefined;
  update_blocks();
  blocks.forEach(b => b.resize());
  init_borders();
  redraw();
}

/*
** set number of balls to launch
*/
function set_nballs(n) {
  nballs = n;
  balls_value.textContent = nballs;
}

/*
** set current level
*/
function set_level(n) {
  level = n;
  level_label.textContent = 'level '+level;
}

/*
** set player credits
*/
function set_credits(n) {
  credits = n;
  credits_value.textContent = credits;
}


/*
** game over
*/
function game_over(elt) {
  state = 'game over';
  elt.style.display = 'block';
  playground.removeEventListener('mousedown',start_shooting);
  home_button.removeEventListener('click',home);
  home_button.style.cursor = 'default';
}

/*
** start new game
*/
function new_game() {
  balls = [];
  playground.addEventListener('mousedown',start_shooting);
  lost.style.display='none';

  if ( credits > 0 ) {
    set_credits(credits-1);
    // not yet hit LauncherLoader bonuses are intentionnaly lost here
    blocks.filter(b => b.row > 4).forEach(b => b.delete());
  }
  else {
    blocks.forEach(b => b.elt.parentNode.removeChild(b.elt));
    next_pos = undefined;
    blocks = [];
    borders = [];
    set_nballs(1);
    set_level(1);
    set_credits(0);
  }
  update_blocks();
  resize();
}

/*
** start next level
*/
function start_next_level() {
  balls = [];
  playground.addEventListener('mousedown',start_shooting);
  won.style.display='none';
  set_credits(credits+1);
  next_level();
}


/*
** change animation speed - event handler
*/
function change_speed() {
  speed = speed_input.value * playground.width/20000;
  speed_value.textContent = speed_input.value;
}

/*
** main program
*/
initialize();
window.onresize = resize;
playground.addEventListener('mousedown',start_shooting);
speed_input.addEventListener('input',change_speed);
lost.addEventListener('click',new_game);
won.addEventListener('click',start_next_level);

</script>
