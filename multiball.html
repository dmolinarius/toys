<!DOCTYPE html>
<html>
<meta charset="utf-8">
<!--
Shoot Bricks v0.0
-->
<title>MultiBall</title>
<style>

/* viewport properties */
html, body {
  padding: 0;
  margin: 0;
  font-family: Consolas;
}

#board, #playground {
  position: absolute;
  width: 56vmin;
  top: calc(50vh - 45vmin);
  left: calc(50vw - 31.5vmin - 2.5px);
  border-radius: 3px;
  border: 5px solid #400;
}

#board {
  background-color: #844;
  height: 90vmin;
  box-shadow: 1vw 1vh 1vmax #420;
  background: linear-gradient(#020, #003800);
}
#playground {
  border: 5px solid #400;
  background-color: transparent;
  height: 80vmin;
  box-shadow: inset -1px -1px 2px #800, inset 1px 1px 2px #400;
}
.block {
  position: absolute;
  background-color: #ccc;
  box-shadow: inset 0 0 3px black;
  line-height: 100%;
  text-align: center;
  font: menu;
  font-weight: bold;
}
#won, #lost {
  display: none;
  cursor: pointer;
  position: absolute;
  height: 4em;
  top: calc(50vh - 2em);
  text-align: center;
  font-size: 3vmin;
  letter-spacing: 0.1em;
  border-radius: 1vmin;
}
#lost {
  width:10em;
  line-height: 4em;
  left: calc(50vw - 5em);
  background-color: #f42;
  color: #ecc;
  box-shadow: inset 0 0 3px #300, 5px 5px 5px rgba(60,0,0,0.6);
  background: linear-gradient(#a00,#f42,#a00);
}
#won {
  width:13em;
  padding-top: 0.7em;
  box-sizing: border-box;
  line-height: 1.33em;
  left: calc(50vw - 6.5em);
  background-color: #192;
  color: #cec;
  box-shadow: inset 0 0 3px #300, 5px 5px 5px rgba(0,30,10,0.6);
  background: linear-gradient(#050,#192,#050);
}
#level_label {
  color: rgba(255,255,255,0.6);
  position: absolute;
  width: 100%;
  text-align: center;
  line-height: 9vmin;
}
#toolbox {
  position: absolute;
  bottom: 0;
  width: 100%;
  height: calc(10vmin - 3px);
  background: linear-gradient(#898, #ccc, #888);
  box-shadow: inset 0 0 5px black;
  border: none;
}
#home_button {
  cursor: default;
  position: absolute;
  width: 3em;
  height: 1.33em;
  line-height: 1.33em;
  left: calc(50% - 1.5em);
  top: calc(5vmin - 0.7em);
  text-align:center;
  border-radius: 3px;
  box-shadow: 0 0 2px black, inset 0 0 2px #777;
  border: 2px solid transparent;
}

</style>

<!-- where blocks live -->
<div id="board">
  <div id="level_label">level 1</div>
  <div id='toolbox'>
   <div id='home_button'>Home</div>
  </div>
</div>

<!-- where launcher & balls live -->
<canvas id="playground"></canvas>

<!-- Game Over popup -->
<div id="lost">Game Over !</div>

<!-- Congrats message -->
<div id="won">Congratulations<br>you won !</div>

<script>
var bw = parseInt(getComputedStyle(playground).getPropertyValue('border-top-width'),10)
  , ctx = playground.getContext('2d') // canvas context
  , state = 'waiting' // app state
  , launcher = null   // launcher object
  , next_pos          // next launcher position
  , blocksize = 0     // cell size
  , blocks = []       // list of block objects
  , nballs = 1        // current number of balls
  , balls = []        // list of ball objects
  , radius = 0        // ball radius
  , walls = []        // list of wall objects, computed from borders and blocks
  , corners = []      // list of Sphere objects, corresponding to block corners
  , level = 1         // current player level
;

/* ****************************************************************************
**
** Ball Class
**
** ***************************************************************************/
class Ball {

  /*
  ** Balls are created with current radius, at launcher position,
  ** and direction depending on launcher orientation
  */
  constructor() {
    this.r = 0.8*radius;
    this.x = launcher.x;
    this.y = launcher.y;
    this.directx = Math.sin(launcher.angle);
    this.directy = -Math.cos(launcher.angle);
  }

  /*
  ** Move ball by given distance, eventually bouncing on obstacles
  */
  move(dist) {
    let dx = dist * this.directx
      , dy = dist * this.directy
      , info = walls.reduce((i,w) => w.check_bounce(i), {minm:2, ball:this, dx, dy, nx:0, ny:0, o:null})
    ;
    if ( info.minm < 1 ) { // bounce on wall
      if ( info.o ) info.o.hit(this);
      this.bounce(dx, dy, info.minm, info.nx, info.ny);
      return;
    }
    info = corners.reduce((i,c) => c.check_bounce(i), {minm:2, ball:this, dx, dy, nx:0, ny:0, o:null});
    if ( info.minm < 1 ) { // bounce on corner
      if ( info.o ) info.o.hit(this);
      this.bounce(dx, dy, info.minm, info.nx, info.ny);
      return;
    }
    // no bounce, just move
    this.x += dx;
    this.y += dy;
  }

  /*
  ** Compute new position after boucing
  */
  bounce(dx, dy, m, nx, ny) {
    // contact point
    let px = this.x + m * dx
      , py = this.y + m * dy;
    // new position
    let sp = (this.x + dx - px)*nx + (this.y + dy - py)*ny;
    this.x = px - sp * nx;
    this.y = py - sp * ny;
    // new direction
    let sd = (this.directx * nx + this.directy * ny);
    this.directx = this.directx - 2 * sd * nx;
    this.directy = this.directy - 2 * sd * ny;
  }

  /*
  ** Draw ball on canvas
  */
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, 2*Math.PI);
    ctx.fill();
    ctx.restore();
  }

  /*
  ** Resize ball by given scale
  */
  resize(s) {
    this.x *= s;
    this.y *= s;
    this.r *= s;
  }
}

/* ****************************************************************************
**
** Ball Launcher
**
** ***************************************************************************/
class Launcher {

  /*
  ** Create Launcher
  */
  constructor() {
    this.position = 0.5;
    this.resize();
    this.angle = 0;
  }

  /*
  ** Update angle to shoot at given coordinates
  */
  lookat(x,y) {
    this.angle = Math.atan((x - this.x)/(this.y - y));
  }

  /*
  ** Move launcher
  */
  move(x) {
    this.x = x;
    this.angle = 0;
    this.position = x / playground.width;
  }

  /*
  ** Resize Launcher (p is playground)
  */
  resize() {
    this.x = this.position * playground.width;
    this.y = playground.height - 3*radius;
  }

  /*
  ** Draw Lancher on canvas
  */
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = 'lime';
    ctx.translate(this.x,this.y);
    ctx.rotate(this.angle);
    ctx.fillRect(-radius, -2*radius, 2*radius, 4*radius)
    ctx.restore();
  }
}

/* ****************************************************************************
**
** A Wall is a segment where balls will bounce
**
** ***************************************************************************/
class Wall {

  /*
  ** Create oriented segment
  ** Normal orientation will depend on order of given points
  */
  constructor(owner, x1,y1,x2,y2) {
    Object.assign(this,{owner, x1, y1, x2, y2});

    // vector
    this.ix = this.x2 - this.x1;
    this.iy = this.y2 - this.y1;

    // norm
    this.norm = Math.sqrt(this.ix*this.ix + this.iy*this.iy);

    // normal
    this.nx = (y1 - y2)/this.norm;
    this.ny = (x2 - x1)/this.norm;
    this.sx = Math.sign(this.nx);
    this.sy = Math.sign(this.ny);

    // segment origin
    this.ax = this.x1 + this.nx * radius;
    this.ay = this.y1 + this.ny * radius;
  }

  /*
  ** Check if moving ball will bounce on segment
  ** https://openclassrooms.com/forum/sujet/calcul-du-point-d-intersection-de-deux-segments-21661
  ** to compute intersection of segments [AB] and [CD] where I is vector such as B = A + kI
  ** and J such as D = C + mJ, let's compute k and m and check if d and m are > 0 and < 1
  */
  check_bounce(info) {
    let cx = info.ball.x, cy = info.ball.y, jx = info.dx, jy = info.dy;
    if ( Math.sign(this.nx)*Math.sign(jx) > 0 && Math.sign(this.ny)*Math.sign(jy) > 0 ) {
      return info;
    }
    let ax = this.ax, ay = this.ay, ix = this.ix, iy = this.iy
      , d = (ix*jy-iy*jx)
      , m = (ix*(ay-cy)+iy*(cx-ax))/d
      , k = (jy*(cx-ax)+jx*(ay-cy))/d
    ;
    if ( m > 0 && m < 1 && k > 0 && k < 1 ) {
      if ( m < info.minm) return {...info, minm:m, nx:this.nx, ny:this.ny, o:this.owner};
    }
    return info;
  }
}

/* ****************************************************************************
**
** Spheres are used to implement block corners
**
** ***************************************************************************/
class Sphere {

  /*
  ** Create Sphere - Owner is block the corner belongs to
  */
  constructor(owner, x,y,r) {
    Object.assign(this,{owner, x, y, r});
    this.r2 = this.r * this.r;
  }

  /*
  ** Check if moving ball will bounce on sphere
  ** Model of ball is as above, model of sphere is P / OP = r
  */
  check_bounce(info) {
    let cx = info.ball.x, cy = info.ball.y, jx = info.dx, jy = info.dy
      , cmox = cx - this.x, cmoy = cy - this.y
      , a = jx*jx + jy*jy
      , b = 2*(cmox*jx + cmoy*jy)
      , c = cmox*cmox + cmoy*cmoy - this.r2
      , delta = b*b - 4*a*c
    ;
    if ( delta < 0 ) return info;
    let sqd = Math.sqrt(delta)
      , m1 = (-b-sqd)/2/a
      , m2 = (-b+sqd)/2/a
    ;
    if ( (m1 < 0 || m1 > 1) && (m2 < 0 || m2 > 1) ) return info;
    let m;
    if ( m2 < 0 || m2 > 1) m = m1;
    else if ( m1 < 0 || m1 > 1 ) m = m2
    else m = Math.min(m1,m2);
    let n = this.normal(cx + m*jx, cy + m*jy);
    return m < info.minm ? {...info, minm:m, ...n, o:this.owner} : info;
  }

  /*
  ** returns normal at given point
  */
  normal(x,y) {
    return {
      nx: (x - this.x)/this.r,
      ny: (y - this.y)/this.r
    }
  }
}

/* ****************************************************************************
**
** Blocks are the obstacles balls bounce on
**
** ***************************************************************************/
class Block {

  /*
  ** Blocks are created at given column and row, with current level
  */
  constructor(col,row,level) {
    this.level = level;
    this.col = col;
    this.row = row;
    this.elt = document.createElement('div');
    this.elt.textContent = this.level
    this.elt.className = 'block';
    this.repaint()
    this.resize();
    window.board.appendChild(this.elt);
  }

  /*
  ** Return coords of block corners
  */
  coords() {
    return{
      x1: (this.col-1)*blocksize,
      y1: (this.row-1)*blocksize,
      x2: (this.col  )*blocksize,
      y2: (this.row-1)*blocksize,
      x3: (this.col  )*blocksize,
      y3: (this.row  )*blocksize,
      x4: (this.col-1)*blocksize,
      y4: (this.row  )*blocksize
    };
  }

  /*
  ** Create walls where balls will bounce
  */
  walls(a) {
    let c = this.coords();
    return a.concat([
      new Wall(this,c.x1,c.y1,c.x4,c.y4),
      new Wall(this,c.x4,c.y4,c.x3,c.y3),
      new Wall(this,c.x3,c.y3,c.x2,c.y2),
      new Wall(this,c.x2,c.y2,c.x1,c.y1)
    ]);
  }

  /*
  ** Create corners where balls will bounce
  */
  corners(a) {
    let c = this.coords();
    return a.concat([
      new Sphere(this,c.x1,c.y1,radius),
      new Sphere(this,c.x2,c.y2,radius),
      new Sphere(this,c.x3,c.y3,radius),
      new Sphere(this,c.x4,c.y4,radius)
    ]);
  }

  /*
  ** Resize block
  */
  resize() {
    this.elt.style.left = (this.col-1)*blocksize+'px';
    this.elt.style.top = (this.row-1)*blocksize+'px';
    this.elt.style.width = blocksize+'px';
    this.elt.style.height = blocksize+'px';
    this.elt.style.lineHeight = blocksize+'px';
    this.elt.style.fontSize = (blocksize/3)+'px';
  }

  /*
  ** Repaint block depending on block level
  */
  repaint() {
    let p = color_palette.reduceRight((p,cp,j) => this.level < cp.i ? {...cp, j} : p, null)
      , l = p ? this.level - color_palette[p.j-1].i : undefined
      , color = p ? p.color(p.f(l)) : 'white'
    ;
    this.elt.style.backgroundColor = color;
  }

  /*
  ** Block has been hit, decrease level and repaint
  ** or eventually delete block of level is < 1
  */
  hit(ball) {
    this.level = this.level - 1;
    this.elt.textContent = this.level;
    if ( this.level < 1 ) remove_block(this);
    else this.repaint();
  }
}

/*
** block color palette
*/
var color_palette = [
  { i: 1 },
  { i: 9,  f: l =>  8*l, color: c => rgb(192+c,192-c,192-c) },
  { i: 17, f: l => 16*l, color: c => rgb(255,128,128+c) },
  { i: 25, f: l => 16*l, color: c => rgb(255-c,128,255) },
  { i: 33, f: l =>  8*l, color: c => rgb(128-2*c,128+c,255-3*c) },
  { i: 49, f: l =>  4*l, color: c => rgb(4*c,192+c,64-c) },
  { i: 57, f: l => 16*l, color: c => rgb(255,255-c,0) },
  { i: 65, f: l => 16*l, color: c => rgb(255,128-c,0) },
  { i: 80, f: l => 16*l, color: c => rgb(255-c,0,c) },
];

/*
** Helper function, return CSS rgb string
*/
function rgb(r,g,b) {
  return 'rgb('+r+','+g+','+b+')';
}

/*
** Initialize app
*/
function initialize() {
  init_consts();
  launcher = new Launcher(playground);
  update_blocks();
  resize();
}

/*
** Initialize app constants depending on window size
*/
function init_consts() {
  blocksize = playground.width / 7;
  radius = playground.width / 40;
}

/*
** Scroll existing blocks down, and create a new row of blocks
*/
function update_blocks() {
  blocks.forEach(b => b.row += 1);
  let num = 2 + random_int(4)
    , available_cols = [1, 2, 3, 4, 5, 6, 7]
  ;
  for ( let n=0; n < num; n++ ) {
    let i = random_int(available_cols.length);
    let col = available_cols[i-1];
    blocks.push(new Block(col,2,Math.floor(6*level/num)));
    available_cols.splice(i-1,1);
  }
}

/*
** not used in normal use - display block color palette
*/
function test_palette() {
  for ( let row = 0; row <10 ; row++ ) {
    for ( let col = 0; col < 7; col++ ) {
      blocks.push(new Block(col+1,row+1, 1 + row*7 + col));
    }
  }
}

/*
** Helper function, return a random integer
*/
function random_int(max) {
  var n = Math.ceil(Math.random() * max);
  return n;
}

/*
** Create walls and corners from playground borders, and list of blocks
*/
function init_obstacles() {
  // playground borders
  walls = [
    new Wall(null,0,0, playground.width,0),
    new Wall(null,playground.width,0, playground.width,playground.height),
    new Wall(bottom(),playground.width,playground.height, 0,playground.height),
    new Wall(null,0,playground.height, 0,0)
  ];
  // blocks
  walls = blocks.reduce((w,b) => b.walls(w),walls);
  corners = blocks.reduce((c,b) => b.corners(c),[]);
}

/*
** hit member of returned object is to be called when a ball hits bottom of playground
*/
function bottom() {
  return {
    hit: function(ball) {
      if ( next_pos === undefined ) next_pos = ball.x;
      balls.splice(balls.indexOf(ball),1);
      delete ball;
      if ( balls.length < 1 ) {
        stop();
        next_level();
      }
    }
  }
}

/*
** Remove a block from list of blocks, as well as his walls, corners and DOM element
*/
function remove_block(b) {
  walls.filter(w => w.owner == b).forEach(w => {walls.splice(walls.indexOf(w),1); delete w});
  corners.filter(c => c.owner == b).forEach(c => {corners.splice(corners.indexOf(c),1); delete c});
  blocks.splice(blocks.indexOf(b),1);
  b.elt.parentNode.removeChild(b.elt);
  delete b;
  if ( blocks.length < 1 ) game_over(won);
}

/*
** Resize whole app
*/
function resize() {
  let scale = playground.clientWidth/playground.width;
  playground.width = playground.clientWidth;
  playground.height = playground.clientHeight;
  init_consts();
  launcher.resize(playground);
  blocks.forEach(b => b.resize());
  balls.forEach(b => b.resize(scale));
  init_obstacles();
  redraw();
}

/*
** Redraw canvas
*/
function redraw() {
  erase();
  launcher.draw(ctx);
  balls.forEach(b => b.draw(ctx));
}

/*
* Erase canvas
*/
function erase() {
  ctx.clearRect(0,0,playground.width,playground.height);
}

/*
** mouse down on canvas - start shooting
*/
function start_shooting(e) {
  playground.removeEventListener('mousedown',start_shooting);
  playground.addEventListener('mousemove',shoot);
  playground.addEventListener('mouseup',fire);
}

/*
** mouse move on canvas - shoot
*/
function shoot(e) {
  var x = e.layerX - bw
    , y = Math.min(launcher.y - radius, e.layerY - bw)
  ;
  state = 'shooting';

  erase();
  launcher.lookat(x,y);
  launcher.draw(ctx);

  ctx.save();
  ctx.strokeStyle = 'white';
  ctx.setLineDash([2,2]);
  ctx.beginPath();
  ctx.moveTo(launcher.x,launcher.y);
  ctx.lineTo(x,y);
  ctx.stroke();
  ctx.restore();
}

/*
** mouse up on canvas - fire balls
*/
function fire(e) {
  playground.removeEventListener('mousemove',shoot);
  playground.removeEventListener('mouseup',fire);

  let steps = 0             // current number of animation steps
    , start = null          // animation start timestamp
    , previous = null       // previous animation step timestamp
    , launched_balls = 0    // current number of launched balls
  ;
  state = 'playing';
  balls = [];
  home_button.addEventListener('click',home);
  home_button.style.cursor = 'pointer';
  requestAnimationFrame(nextStep);

  /*
  ** functions below inlined to use closure
  */

  // launch a new ball
  function launch_ball() {
    balls.push(new Ball);
    launched_balls += 1;
  }

  // animation step
  function nextStep(timestamp) {
    if ( !start ) {
      start = timestamp;
      previous = start;
    }
    steps += 1;

    // while some balls still to launch ...
    if ( state=='playing' && launched_balls < nballs ) {
      // launch first ball ...
      if (balls.length == 0) launch_ball();
      // ... and other ones at 3 radius distance from each others
      else {
        let ball = balls[balls.length-1]
          , dx = ball.x - launcher.x
          , dy = ball.y - launcher.y
          , d = Math.sqrt(dx*dx + dy*dy)
        ;
        if ( d > radius*3 ) launch_ball();
      }
    }

    // move all balls forward and redraw
    let dist = (timestamp - previous)*playground.width/800;
    balls.forEach(b => b.move(dist));
    redraw();

    // if still playing register next animation step
    if ( state == 'playing' ) requestAnimationFrame(nextStep);
    previous = timestamp;
  }
}

/*
** end current turn by recalling all moving balls home
*/
function home(e) {
  home_button.removeEventListener('click',home);
  home_button.style.cursor = 'default';
  stop();
  balls = [];
  next_level();
}

/*
** be prepared to shoot again
*/
function stop() {
  state = 'waiting';
  playground.addEventListener('mousedown',start_shooting);
}

/*
** prepare next turn
*/
function next_level() {
  if ( blocks.filter(b => b.row > 8).length > 0 ) game_over(lost);
  else {
    level += 1;
    nballs += 1;
    level_label.textContent = 'level '+level;
    if ( next_pos !== undefined ) launcher.move(next_pos);
    next_pos = undefined;
    update_blocks();
    blocks.forEach(b => b.resize());
    init_obstacles();
    redraw();
  }
}

/*
** game over
*/
function game_over(elt) {
  state = 'game over';
  elt.style.display = 'block';
  playground.removeEventListener('mousedown',start_shooting);
}

/*
** start new game
*/
function new_game() {
  blocks.forEach(b => b.elt.parentNode.removeChild(b.elt));
  next_pos = undefined;
  blocks = [];
  nballs = 1;
  balls = [];
  radius = 0;
  walls = [];
  corners = [];
  level = 1;
  level_label.textContent = 'level '+level;
  update_blocks();
  resize();
  playground.addEventListener('mousedown',start_shooting);
  lost.style.display='none';
  won.style.display='none';
}

/*
** main program
*/
initialize();
window.onresize = resize;
playground.addEventListener('mousedown',start_shooting);
lost.addEventListener('click',new_game);
won.addEventListener('click',new_game);

</script>
