<!DOCTYPE html>
<html>
<meta charset="utf-8">
<!--
Shoot Bricks v0.0
-->
<title>MultiBall</title>
<style>

/* viewport properties */
html, body {
  padding: 0;
  margin: 0;
  font-family: Consolas;
}

#board, #playground {
  position: absolute;
  width: 70vmin;
  height: 90vmin;
  top: calc(50vh - 45vmin);
  left: calc(50vw - 35vmin - 2.5px);
  border-radius: 3px;
  border: 5px solid #400;
}

#board {
  box-shadow: 1vw 1vh 1vmax #420;
  background-color: #844;
}
#playground {
  border: 5px solid #400;
  background-color: transparent;
}

</style>

<div id="board"></div>
<canvas id="playground"></canvas>

<script>
var bw = parseInt(getComputedStyle(playground).getPropertyValue('border-top-width'),10)
  , ctx = playground.getContext('2d')
  , state = 'waiting'
  , launcher = null
  , ball = null
  , radius = 0
  , walls = []
;

class Ball {
  constructor() {
    this.r = 0.8*radius;
    this.x = launcher.x;
    this.y = launcher.y;
    this.directx = Math.sin(launcher.angle);
    this.directy = Math.cos(launcher.angle);
  }
  move(dist) {
    let dx = dist * this.directx
      , dy = - dist * this.directy
      , minm = 2
      , info = walls.reduce((o,w) => w.check_bounce(o), {minm, ball:this, dx, dy, wall:null})
    ;
    if ( info.minm < 1 ) { // we should bounce
      // bounce point
      let px = this.x + info.minm * dx
        , py = this.y + info.minm * dy;
      // new position
      let sp = (this.x + dx - px)*info.wall.nx + (this.y + dy - py)*info.wall.ny;
      this.x = px - sp * info.wall.nx;
      this.y = py - sp * info.wall.ny;
      // new direction
      let sd = (this.directx * info.wall.nx + this.directy * info.wall.ny);
      this.directx = this.directx - 2 * sd * info.wall.nx;
      this.directy = this.directy - 2 * sd * info.wall.ny;
    }
    else { // no bounce
      this.x += dx;
      this.y += dy;
    }
  }
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, 2*Math.PI);
    ctx.fill();
    ctx.restore();
  }
  resize(s) {
    this.x *= s;
    this.y *= s;
    this.r *= s;
  }
}
class Launcher {
  constructor(p,r) {
    this.resize(p);
    this.angle = 0;
  }
  lookat(x,y) {
    this.angle = Math.atan((x - this.x)/(this.y - y));
  }
  resize(p) {
    this.x = p.width/2;
    this.y = p.height - 3*radius;
  }
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = 'lime';
    ctx.translate(this.x,this.y);
    ctx.rotate(this.angle);
    ctx.fillRect(-radius, -2*radius, 2*radius, 4*radius)
    ctx.restore();
  }
}
class Wall {
  constructor(x1,y1,x2,y2) {
    Object.assign(this,{x1, y1, x2, y2});

    // vector
    this.ix = this.x2 - this.x1;
    this.iy = this.y2 - this.y1;

    // norm
    this.norm = Math.sqrt(this.ix*this.ix + this.iy*this.iy);

    // normal
    this.nx = (y1 - y2)/this.norm;
    this.ny = (x2 - x1)/this.norm;
    this.sx = Math.sign(this.nx);
    this.sy = Math.sign(this.ny);

    // "bouncing segment" origin
    this.ax = this.x1 + this.nx * radius;
    this.ay = this.y1 + this.ny * radius;
  }
  // https://openclassrooms.com/forum/sujet/calcul-du-point-d-intersection-de-deux-segments-21661
  // to compute intersection of segments [AB] and [CD] where I is vector such as B = A + kI
  // and J such as D = C + mJ, let's compute k and m and check if d and m are > 0 and < 1
  check_bounce(info) {
    let cx = info.ball.x, cy = info.ball.y, jx = info.dx, jy = info.dy;
    if ( Math.sign(this.nx)*Math.sign(jx) > 0 && Math.sign(this.ny)*Math.sign(jy) > 0 ) {
      return info;
    }
    let ax = this.ax, ay = this.ay, ix = this.ix, iy = this.iy
      , d = (ix*jy-iy*jx)
      , m = (ix*(ay-cy)+iy*(cx-ax))/d
      , k = (jy*(cx-ax)+jx*(ay-cy))/d
    ;
    if ( m > 0 && m < 1 && k > 0 && k < 1 ) {
      if ( m < info.minm) return {...info, minm:m, wall:this};
    }
    return info;
  }
}
function initialize() {
  radius = playground.width / 28;
  launcher = new Launcher(playground);
  resize();
}
function init_walls() {
  walls = [
    new Wall(0,0, playground.width,0),
    new Wall(playground.width,0, playground.width,playground.height),
    new Wall(playground.width,playground.height, 0,playground.height),
    new Wall(0,playground.height, 0,0)
  ];
}
function resize() {
  let scale = playground.clientWidth/playground.width;
  playground.width = playground.clientWidth;
  playground.height = playground.clientHeight;
  radius = playground.width / 28;
  launcher.resize(playground);
  if ( ball ) ball.resize(scale);
  init_walls();
  redraw();
}
function redraw() {
  erase();
  launcher.draw(ctx);
  if ( ball ) ball.draw(ctx);
}
function erase() {
  ctx.clearRect(0,0,playground.width,playground.height);
}
function start_shooting(e) {
  playground.removeEventListener('mousedown',start_shooting);
  playground.addEventListener('mousemove',shoot);
  playground.addEventListener('mouseup',fire);
}
function shoot(e) {
  var x = e.layerX - bw
    , y = Math.min(launcher.y, e.layerY - bw)
  ;
  state = 'shooting';

  erase();
  launcher.lookat(x,y);
  launcher.draw(ctx);

  ctx.save();
  ctx.strokeStyle = 'white';
  ctx.setLineDash([2,2]);
  ctx.beginPath();
  ctx.moveTo(launcher.x,launcher.y);
  ctx.lineTo(x,y);
  ctx.stroke();
  ctx.restore();
}
function fire(e) {
  playground.removeEventListener('mousemove',shoot);
  start();
}
function start() {
  var start = null
    , previous = null
    , steps = 0
  ;
  state = 'playing';
  ball = new Ball();
  erase();
  launcher.draw(ctx);
  requestAnimationFrame(nextStep);

  // inlined to use closure
  function nextStep(timestamp) {
    if ( !start ) {
      start = timestamp;
      previous = start;
    }
    steps += 1;

    let dist = timestamp - previous;
    ball.move(dist);
    redraw();

    if ( ball.y < playground.height - 2*radius) {
      requestAnimationFrame(nextStep);
    }
    else stop();
    previous = timestamp;
  }
}
function stop() {
  state = 'waiting';
  playground.addEventListener('mousedown',start_shooting);
}

initialize();
window.onresize = resize;
playground.addEventListener('mousedown',start_shooting);

</script>
